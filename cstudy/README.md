# 一、C语言数组详解（包括概念、定义、初始化、内存布局等）



所谓数组，就是一组数据的集合，或者说有序排列，C语言中的数组允许我们在连续的内存位置存储相同类型的多个元素。数组在编程中扮演着至关重要的角色，因为它们能够有效地组织和管理大量相关数据。


数组的概念可以理解为一系列相同类型的数据元素的有序集合。想象一下，你有一排整齐的储物柜，每个柜子都可以存放同样类型的物品。这就是数组的基本思想：一个变量名代表了多个相同类型的数据元素，这些元素按照固定的顺序排列在内存中。

## 数组的定义、初始化和访问

在C语言中，一维数组的定义遵循特定的语法规则，一般形式如下：

```c
数据类型 数组名[元素个数];
```

这里，`数据类型`指定了数组中每个元素的类型（如 int、float、char 等），`数组名`是我们给这个数组起的标识符，方括号`[ ]`中的`元素个数`则定义了数组可以存储的元素数量。


让我们看几个具体的数组声明示例：

```c
int scores[5];           // 声明一个包含 5 个整数的数组
float temperatures[100]; // 声明一个可以存储 100 个浮点数的数组
char name[20];           // 声明一个可以存储 20 个字符的数组
```

在这些例子中，我们分别声明了一个整型数组、一个浮点型数组和一个字符数组。需要注意的是，数组的大小必须是一个常量表达式，也就是说，它的值在编译时就必须确定。


C语言还允许我们在声明数组的同时进行初始化，这可以通过以下方式实现：

```c
int numbers[ ] = {1, 2, 3, 4, 5};  // 编译器会自动计算数组大小 5
int partial[5] = {1, 2};  // 剩余元素会被自动初始化为 0
char vowels[ ] = {'a', 'e', 'i', 'o', 'u'};// 编译器会自动计算数组大小 5
char name[5] = {'a', 'e'};	// 剩余元素会被自动初始化为 '\0'
char c[10]="Hello";
```

在第1,3个例子中，我们没有明确指定数组的大小，编译器会根据初始化列表自动计算。

第2,4个例子则说明，**如果初始化值的数量少于数组大小，剩余的元素会被自动初始化为 0（对于数值类型）或 '\0'（对于字符类型）。**


数组的使用方法非常直观，我们可以通过索引（下标）来访问或修改数组中的元素。在C语言中，数组的索引是从 0 开始的。这意味着第一个元素的索引是 0，第二个是 1，依此类推。

访问数组元素的语法格式如下：

```
数组名[索引]
```

例如，要访问上面声明的 numbers 数组中的第三个元素（索引为 2），我们可以这样写：

```c
int third_element = numbers[2];
printf("第三个元素是：%d\n", third_element);
```

输出结果：

```
第三个元素是：30
```

我们也可以使用索引来修改数组中的元素：

```
numbers[2] = 35;  // 将第三个元素的值修改为 35printf("修改后的第三个元素是：%d\n", numbers[2]);
```

输出结果：

```
修改后的第三个元素是：35
```

## 数组的内存布局

理解数组的内存布局对于深入掌握数组的工作原理至关重要。在C语言中，一维数组在内存中是以连续的方式存储的，这意味着数组的元素在内存中彼此相邻，没有间隔。**数组名**实际上是一个**指向数组第一个元素的指针**。


假设我们有一个整型数组 int arr[5]，在 32 位系统中，每个整数占用 4 个字节。那么这个数组在内存中的布局可能如下所示：

```c
内存地址     |    值
0x1000      |   arr[0]
0x1004      |   arr[1]
0x1008      |   arr[2]
0x100C      |   arr[3]
0x1010      |   arr[4]
```

这种连续的内存布局使得数组访问非常高效，当我们使用索引访问数组元素时，编译器会计算元素的确切内存地址。例如，**要访问 arr[2]，编译器会计算：基地址（arr 的地址）+ 2 * sizeof(int)**。


了解数组的内存布局还有助于我们理解数组名和指针之间的关系。

在大多数情况下，**数组名可以被视为指向数组第一个元素的常量指针**。这就是为什么我们可以使用指针算术来操作数组：

```C
int numbers[5] = {10, 20, 30, 40, 50};
int *ptr = numbers;  // ptr 指向数组的第一个元素
printf("第一个元素：%d\n", *ptr);      // 输出 10
printf("第二个元素：%d\n", *(ptr + 1));  // 输出 20
printf("第三个元素：%d\n", *(ptr + 2));  // 输出 30
```


以下是一个简单的示例，展示了如何使用 sizeof 运算符来查看数组及其元素的内存占用情况：

```c
#include <stdio.h>
int main() {    
    int numbers[5] = {10, 20, 30, 40, 50};        
    printf("整个数组占用的内存大小：%zu 字节\n", sizeof(numbers));    
    printf("每个数组元素占用的内存大小：%zu 字节\n", sizeof(numbers[0]));   
    printf("数组元素的个数：%zu\n", sizeof(numbers) / sizeof(numbers[0]));        
    return 0;
}
```

输出结果：

```
整个数组占用的内存大小：20 字节
每个数组元素占用的内存大小：4 字节
数组元素的个数：5
```

这个例子展示了如何使用 sizeof 运算符来获取数组的总大小、单个元素的大小，以及如何计算数组中元素的个数。

## 数组边界检查

C语言不会自动进行数组边界检查，这意味着访问超出数组范围的元素是可能的，但这可能导致未定义的行为。作为程序员，我们有责任确保所有的数组访问都在有效范围内。例如：

```C
int numbers[5] = {10, 20, 30, 40, 50};
numbers[5] = 60;  // 错误：访问超出数组范围的元素
```

上面的代码试图访问 numbers 数组的第六个元素（索引为 5），但这个元素实际上不存在。这种操作可能导致程序崩溃或产生其他意外行为。


为了避免这种情况，我们可以在访问数组元素之前进行边界检查：

```c
#include <stdio.h>
#define ARRAY_SIZE 5
int main() {    
    int numbers[ARRAY_SIZE] = {10, 20, 30, 40, 50};    
    int index;    
    printf("请输入要访问的数组索引：");    
    scanf("%d", &index);    
    if (index >= 0 && index < ARRAY_SIZE) {        
        printf("numbers[%d] = %d\n", index, numbers[index]);   
    } else {       
        printf("错误：索引 %d 超出数组范围！\n", index);    
    }    
    return 0;
}
```

这个例子演示了如何在访问数组元素之前进行边界检查，以确保我们只访问有效的数组元素。这种做法可以提高程序的健壮性和安全性。

## 总结

数组不仅在存储和操作数据方面非常有用，而且也是理解更复杂[数据结构](https://c.biancheng.net/data_structure/)（如多维数组和动态数组）的基础。通过深入理解数组的概念、定义、声明、用法和内存布局，你将能够更有效地设计和实现各种算法和数据处理任务。


然而，数组在C语言中还有一些有趣的特性和限制。例如，我们不能将一个数组直接赋值给另一个数组，也不能用 == 运算符直接比较两个数组。如果需要复制或比较数组，我们通常需要使用循环或标准库函数（如 memcpy() 或 memcmp() 函数）来逐元素操作。



# 二、C语言给数组赋值的方法

## 1. 数组初始化时赋值

在C语言中，我们可以在声明数组的同时为其赋初值；这种方法简洁高效，特别适用于已知数组元素值的情况。以下是几种常见的数组初始化赋值方式：

#### 1) 完全初始化

当我们知道数组的所有元素值时，可以使用完全初始化的方式：

```c
int numbers[5] = {1, 2, 3, 4, 5};
char vowels[5] = {'a', 'e', 'i', 'o', 'u'};
```

在这个例子中，我们分别初始化了一个整型数组和一个字符数组，并为每个元素赋予了具体的值。

#### 2) 部分初始化

如果只想初始化部分元素，可以这样做：

```c
int partial[5] = {1, 2, 3};
```

在这种情况下，数组的前三个元素被初始化为 1、2、3，而剩余的元素会被自动初始化为 0。

#### 3) 省略数组大小

当我们在初始化时提供了所有元素的值，可以省略数组大小，编译器会自动计算：

```c
int auto_size[] = {1, 2, 3, 4, 5};
```

这种方法特别适用于当数组元素较多或者元素数量可能发生变化的情况。

#### 4) 使用指定初始化器（C99 标准及以后）

从 C99 标准开始，C语言引入了指定初始化器，允许我们为特定的数组元素赋值：

```
int specific[10] = {[0] = 1, [5] = 10, [9] = 100};
```

在这个例子中，我们只为索引 0、5 和 9 的元素赋值，其他元素会被自动初始化为 0。

## 运行时给数组赋值

除了在初始化时赋值，我们还经常需要在程序运行过程中给数组元素赋值。以下是几种常见的方法：

#### 1) 使用索引赋值

最直接的方法是通过数组索引来访问和修改数组元素：

```c
int numbers[5];numbers[0] = 10;numbers[1] = 20;numbers[2] = 30;numbers[3] = 40;numbers[4] = 50;
```

这种方法允许我们精确控制每个元素的值，但如果数组较大，逐个赋值可能会显得繁琐。

#### 2) 使用循环赋值

当需要给大型数组赋值或者赋值规律性较强时，使用循环是一种更高效的方法：

```c
int numbers[100];
for (int i = 0; i < 100; i++) {    numbers[i] = i * 2;}
```

这个例子中，我们使用 for 循环为一个包含 100 个元素的数组赋值，每个元素的值是其索引的两倍。

#### 3) 使用函数赋值

有时，我们可能需要通过函数来给数组赋值，这在处理复杂的赋值逻辑或者需要重用赋值代码时特别有用：

```c
void fillArray(int arr[], int size, int value) {   
    for (int i = 0; i < size; i++) {       
        arr[i] = value;    }}
int main() {    
    int numbers[10];    
    fillArray(numbers, 10, 42);    
    return 0;}
```

在这个例子中，我们定义了一个 fillArray 函数，它接受一个数组、数组大小和填充值作为参数，然后用指定的值填充整个数组。

#### 4) 使用指针赋值

对于熟悉指针的程序员来说，使用指针来给数组赋值也是一种选择：

```C
int numbers[5];
int *ptr = numbers;
for (int i = 0; i < 5; i++) {   
    *ptr = i * 10;    
    ptr++;
}
```

这种方法利用了数组名本质上是指向数组第一个元素的指针这一特性。通过移动指针，我们可以顺序访问和修改数组的每个元素。

## 注意事项

在给数组赋值时，有一些重要的注意事项需要牢记：

- 数组越界：确保不要访问或修改超出数组边界的元素，这可能导致未定义行为或程序崩溃。
- 字符串数组：对于字符串数组，不要忘记在字符串末尾添加空字符 '\0'。
- 多维数组：给多维数组赋值时，需要注意正确处理每个维度。
- const 数组：如果数组被声明为 const，就不能在初始化后修改其元素。
- 静态数组：函数内的静态数组只会在程序开始时初始化一次。

# 三、C语言将数组赋值给另一个数组（4种方法）

在C语言中，将一个数组赋值给另一个数组，并不像简单的变量赋值那样直接赋值，这是因为数组名本质上是一个指向数组第一个元素的指针，而不是一个可以直接赋值的变量。因此，我们需要采用其他方法来实现数组之间的赋值。

以下是几种常用的方法。

## 1. 使用循环逐个元素赋值

最直接的方法是使用循环来逐个复制数组元素。这种方法适用于所有类型的数组，无论是整型、浮点型还是字符型。

```c
#include <stdio.h>
#define SIZE 5
int main() {    
    int source[SIZE] = {1, 2, 3, 4, 5};    
    int destination[SIZE];        
    for (int i = 0; i < SIZE; i++) {        
        destination[i] = source[i];   
    }        
    printf("Copied array: ");   
    for (int i = 0; i < SIZE; i++) {       
        printf("%d ", destination[i]);   
    }        
    return 0;
}
```

运行结果：

```
Copied array: 1 2 3 4 5
```

这种方法的优点是简单直观，适用于各种情况。但是，对于大型数组，这种方法可能会比较耗时。

## 2. 使用 memcpy() 函数

对于需要复制大量数据的情况，使用 memcpy() 函数可能会更高效。这个函数来自 <string.h> 库，可以快速复制内存块。

  **void \*memcpy(void \*str1, const void \*str2, size_t n)** 从存储区 **str2** 复制 **n** 个字节到存储区 **str1**。

```c
void *memcpy(void *str1, const void *str2, size_t n)
/*参数
str1 -- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。
str2 -- 指向要复制的数据源，类型强制转换为 void* 指针。
n -- 要被复制的字节数。
返回值
该函数返回一个指向目标存储区 str1 的指针。
*/
```



```c
#include <stdio.h>
#include <string.h>
#define SIZE 5
int main() {    
    int source[SIZE] = {1, 2, 3, 4, 5};    
    int destination[SIZE];    
    
    memcpy(destination, source, sizeof(source));   
    
    printf("Copied array: ");    
    for (int i = 0; i < SIZE; i++) {        
        printf("%d ", destination[i]);    
    }        
    return 0;
}
```

运行结果：

```
Copied array: 1 2 3 4 5
```

memcpy() 函数的优点是效率高，特别是对于大型数组。但需要注意的是，这个函数不检查内存重叠，如果源数组和目标数组有重叠，可能会导致未定义行为。

## 3. 使用 strcpy() 函数（仅适用于字符数组）

如果你处理的是字符数组（字符串），可以使用 strcpy() 函数。这个函数专门用于复制字符串，会自动处理字符串的结束符 '\0'。

```c
char* strcpy ( char* destination, const char* source);
/*
-- destination ：表示目标字符串的地址。
-- source ：表示源字符串的地址。
注意：这里的原字符串地址是被 const 所修饰的常量指针，指向的内容不能被修改,函数的返回值为目标字符串的地址。
*/
 
```





```c
#include <stdio.h>
#include <string.h>
#define SIZE 20
int main() {    
    char source[SIZE] = "Hello, World!";    
    char destination[SIZE];        
    strcpy(destination, source);        
    printf("Copied string: %s\n", destination);        return 0;}
```

运行结果：

```
Copied string: Hello, World!
```

strcpy() 函数的优点是使用简单，专门为字符串设计。但要注意确保目标数组有足够的空间来容纳源字符串，否则可能会导致缓冲区溢出。

## 4. 使用指针操作

对于高级用户，可以使用指针操作来复制数组。这种方法可以提供更多的灵活性，但也需要非常小心。

```c
#include <stdio.h>
#define SIZE 5
int main() {    
    int source[SIZE] = {1, 2, 3, 4, 5};    
    int destination[SIZE];       
    int *src_ptr = source;    
    int *dest_ptr = destination;        
    for (int i = 0; i < SIZE; i++) {        
        *dest_ptr++ = *src_ptr++;    }        
    printf("Copied array: ");    
    for (int i = 0; i < SIZE; i++) {        
        printf("%d ", destination[i]);    
    }        
    return 0;
}
```

运行结果：

```
Copied array: 1 2 3 4 5
```

使用指针操作的优点是可以提供更多的控制，例如可以只复制部分数组或者以特定的步长复制。但是这种方法也更容易出错，需要仔细管理指针以避免越界访问。

## 总结

在进行数组赋值时，需要注意以下几点：

- 确保目标数组的大小至少与源数组一样大，以避免缓冲区溢出。
- 如果使用 memcpy() 或指针操作，要特别注意内存重叠的问题。
- 对于多维数组，可能需要使用嵌套循环或特殊的内存复制技术。
- 对于大型数组，考虑使用动态内存分配（malloc() 和 free()）来管理内存。


选择哪种方法取决于具体的需求和情况。对于小型数组或简单情况，使用循环复制可能更直观。对于大型数组或性能敏感的情况，memcpy() 可能是更好的选择。对于字符数组，strcpy() 通常是最方便的选项。

无论选择哪种方法，都要确保正确处理数组边界和内存管理，以编写安全、高效的代码。

# ⼆级指针
指针变量也是变量，是变量就有地址，那指针变量的地址存放在哪⾥？答案是：更高级别的指针！

这就是 ⼆级指针。

![C Pointer to Pointer (Theory & Example) - ElectricalWorkbook](D:\OfficeSpace\MarkdownNotes\cstudy\R-C.ca67fbe20295671ed253c71038f09612)

![Understand Pointers in C in depth](D:\OfficeSpace\MarkdownNotes\cstudy\OIP-C.IfDiLcxZNYULYwmjHkp7HwHaEc)

<img src="D:\OfficeSpace\MarkdownNotes\cstudy\image-20241026215319127.png" alt="image-20241026215319127" style="zoom:67%;" />

<img src="D:\OfficeSpace\MarkdownNotes\cstudy\image-20241026215554346.png" alt="image-20241026215554346" style="zoom:67%;" />

![img](D:\OfficeSpace\MarkdownNotes\cstudy\c750d34b3dfa11e46171473a6a19028d.png)

对于⼆级指针的运算有：

1.*ppa 通过对ppa中的地址进⾏解引⽤，这样找到的是 

int b = 20;

*ppa = &b;// 等价于 pa = &b; pa ， *ppa 其实访问的就是 pa .

2.**ppa 先通过 *ppa 找到 pa ,然后对pa进行解应用操作：*pa，那找到的是a。

**ppa = 30;

// 等价于 *pa = 30;

// 等价于 a = 30;



![how double pointer works in C](D:\OfficeSpace\MarkdownNotes\cstudy\working-of-double-pointers.webp)


# 四、指针数组

-  我们类⽐⼀下，整型数组，是存放整型的数组，字符数组是存放字符类型的数组。 那指针数组呢？那当然是存放指针类型的数组.

![img](D:\OfficeSpace\MarkdownNotes\cstudy\5712f245ee9d6f51d99694fdfca5e9df.png)

指针数组的每个元素都是⽤来存放地址（指针）的。 如下图：

![img](D:\OfficeSpace\MarkdownNotes\cstudy\4690d9e2f7e163ecda4b8c046505f233.png)

指针数组的每个元素是地址，⼜可以指向⼀块区域.

- 指针数组的定义形式一般为：

dataType *arrayName[length];

`[ ]`的优先级高于 * ，该定义形式应该理解为：

 `首先， 是一个数组，包含了`length`个元素； `

`其次， 每个元素的类型为 `dataType *`。

- 下面是一个简单的例子：

```c
#include <stdio.h>
int main(){   
    int a = 16, b = 932, c = 100;    //定义一个指针数组    
    int *arr[3] = {&a, &b, &c};//也可以不指定长度，直接写作 int *arr[]    
    //定义一个指向指针数组的指针    
    int **parr = arr;
    printf("%d, %d, %d\n", &a, &b, &c); 
    printf("%d, %d, %d\n", *arr[0], *arr[1], *arr[2]);    
    printf("%d, %d, %d\n", **(parr+0), **(parr+1), **(parr+2));   
    return 0;
}
```

运行结果：
16, 932, 100
16, 932, 100

16, 932, 100

arr 是一个指针数组，它包含了 3 个元素，每个元素都是一个指针，在定义 arr 的同时，我们使用变量 a、b、c 的地址对它进行了初始化，这和普通数组是多么地类似。

parr 是指向数组 arr 的指针，确切地说是指向 arr 第 0 个元素的指针，它的定义形式应该理解为`int *(*parr)`，括号中的`*`表示 parr 是一个指针，括号外面的`int *`表示 parr 指向的数据的类型。arr 第 0 个元素的类型为 int *，所以在定义 parr 时要加两个 *。

第一个 printf() 语句中，arr[i] 表示获取第 i 个元素的值，该元素是一个指针，还需要在前面增加一个 * 才能取得它指向的数据，也即 *arr[i] 的形式。

第二个 printf() 语句中，parr+i 表示第 i 个元素的地址，*(parr+i) 表示获取第 i 个元素的值（该元素是一个指针），**(parr+i) 表示获取第 i 个元素指向的数据。



**后续学习**： [C语言指针与数组（不适合初学者版）：一篇文章带你深入了解指针与数组！-CSDN博客](https://blog.csdn.net/2302_80208388/article/details/136738077)

[C语言指针数组（数组每个元素都是指针）详解 - C语言中文网](https://c.biancheng.net/view/2020.html)

![image-20241026213759005](D:\SwirebevUser\chennl\AppData\Roaming\Typora\typora-user-images\image-20241026213759005.png)





## C语言枚举

#### 1 枚举是用来干嘛的？
枚举在C语言中其实是一些**符号常量集**。 直白点说：枚举定义了一些符号， 这些常量符号 对应一个**int类型**的常量，本质上就是， 每个符号和一个常量绑定。 

- 一般情况下我们都不明确指定这个符号所对应的数字，而让编译器自动分配。

- 编译器自动分配的原则是：从0开始依次增加。
- 如果用户自己定义了一个值，则从那个值开始往后依次增加。

#### 2 C语言为何需要枚举？

C语言没有枚举是可以的。使用枚举其实就是对一些数字进行符号化编码，这样的好处就是编程时可以不用看数字而直接看符号。符号的意义是**直观**，一眼可以看出。而数字所代表的含义除非看文档或者注释。

比如，我们定义红黑树节点结构，第1 种方法， 使用 1- 代表红色    2-代表黑色； 第2种方法， RED  - 代表 红色   BLACK -代表黑色。 显然，第2 种直观，不需要注解。



枚举语法定义格式为：

```c
enum 枚举名
{
    枚举元素1,枚举元素2,……     //注意，各元素之间用逗号隔开
};  //注意，末尾有分号；

//
enum color{ RED,BLACK};
//编译器自动分配的原则是：从0开始依次增加, 所以，RED对应整数为____, BLACK:_________
```

 

```C
enum DAY
{
     MON=1, TUE, WED, THU, FRI, SAT, SUN
};

enum WEEKDAY//跟第一个定义不同的是，此处的标号DAY省略，这是允许的。
{
    saturday,
    sunday = 0,
    monday,
    tuesday,
    wednesday,
    thursday,
    friday
};
```

## 使用枚举变量

 **先声明后赋值（常用）**

```c

/* 定义枚举类型 */
enum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN };
 
void main()
{
    /* 使用基本数据类型声明变量，然后对变量赋值 */
    int x, y, z;
    
    x = 10;
    y = 20;
    z = 30;
    
    /* 使用枚举类型声明变量，再对枚举型变量赋值 */
    enum DAY yesterday, today, tomorrow;
    
    yesterday = MON;
    today     = TUE;
    tomorrow  = WED;
 
    printf("%d %d %d \n", yesterday, today, tomorrow);


    //思考，以下是否可以？
     enum DAY day1 = 100;
     enum DAY day2 = 100.58;
```

